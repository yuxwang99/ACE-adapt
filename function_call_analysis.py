# - function_call_analysis.py - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
# - Parse the Matlab code and analyze the sub-function call pattern - - - - - - - - - - #
import os
import re
from utils.parser.line import generate_valid_code_line
from utils.visualization import call_graph_viz
from utils.parser.parse_expr import parse_nested_expr
from utils.parser.expr_class import CallExprAST
from function_tag import remove_cmt_paragraph


class FunctionCall:
    """
    FunctionCall implements a function node that includes the function name,
    input variables, output variables, and the connection to the parent and
    child nodes.
    """

    def __init__(self, func_name, input_vars=[], output_vars=[]):
        self.func_name = func_name
        self.input_vars = input_vars
        self.output_vars = output_vars
        self.cnt_vars_parents = {}
        self.cnt_vars_children = {}

        self.child_nodes = []
        self.parent_nodes = []

    def add_child_node(self, child_func):
        """
        Connect the child node to the current node
        Args:
            child_func: the child node
        """
        for node in self.child_nodes:
            if node.func_name == child_func.func_name:
                return
        self.child_nodes.append(child_func)

    def add_parent_node(self, parent_func):
        """
        Connect the parent node to the current node
        Args:
            parent_func: the parent node local_vars: internal variables
        """
        for node in self.parent_nodes:
            if node.func_name == parent_func.func_name:
                return
        self.parent_nodes.append(parent_func)


def function_called(func_name: str, callee: list, prefix="") -> None:
    for func in callee:
        if func.func_name == func_name:
            return func
        elif func.func_name == prefix + func_name:
            return func


def is_sub_func_called(func_name: str, call_pattern, sub_folders: list[str]):
    """
    Check whether the function is called in the specified folders

    Args:
        func_name (str): function name
        call_pattern (dict): User defined function attributes of generated by function_tag.py
        sub_folders (list[str]): Sub folders in root_dir that are used.

    Returns:
        func_name: full function name including the sub folder name
    """
    sub_func_sets = call_pattern
    if isinstance(call_pattern, dict):
        sub_func_sets = call_pattern.keys()

    for sub_folder in sub_folders:
        sub_func_dir = os.path.join(sub_folder, func_name)
        if sub_func_dir in sub_func_sets:
            return sub_func_dir

    if func_name in sub_func_sets:
        return func_name

    return None


def call_analysis_code(
    code_cont: str,
    func_entity: FunctionCall,
    function_attributes: dict,
    code_dir: str,
    sub_func_folders=[],
    par_func_list=[],
):
    """
    Analyze the variable usage in the function body

    Args:
        code_cont (str): String body of the function
        func_entity (FunctionCall): FunctionCall object of the function
        function_attributes (dict): Function attributes of generated by function_tag.py
        code_dir (str): Directory of the code
        sub_func_folders (list, optional): Sub folders in root_dir that are used. Defaults to [].
        par_func_list (list, optional): Parent function list. Defaults to [].
    """
    for line in generate_valid_code_line(code_cont):
        # skip the function definition
        if line.strip().startswith("function"):
            continue

        result = re.split(r"(?<=[^<>=~])=(?![<>=~])", line)
        # skip line without statement "="
        if len(result) < 2:
            continue
        rhs_content = result[1]
        paren_ind = rhs_content.find("(")

        # not a function call, skip
        if paren_ind == -1:
            continue

        rhs_ast = parse_nested_expr(rhs_content)
        if isinstance(rhs_ast, CallExprAST):
            sub_func_fullname = is_sub_func_called(
                rhs_ast.func_name, function_attributes, sub_func_folders
            )
            if not sub_func_fullname:
                continue

            call_analysis(
                code_dir,
                sub_func_fullname + ".m",
                function_attributes,
                par_func_list,
                parent_func=func_entity,
                sub_func_folders=sub_func_folders,
            )


def call_analysis(
    root_dir: str,
    file_name: str,
    function_attributes: dict,
    visited_funcs=[],
    parent_func=None,
    sub_func_folders=[],
) -> FunctionCall:
    """
    Create a FunctionCall object that connectthe function to its parent node if exists,
    and analyze the variable usage in the function body.
    Construct the function call graph by recursively calling the function.

    Args:
        root_dir (str): Root directory of the code
        file_name (str): File name of the function
        function_attributes (dict):Function attributes generated by function_tag.py
        visited_funcs (list, optional): Pre_visited function list. Defaults to [].
        parent_func (FunctionCall, optional): Callee function. Defaults to None.
        sub_func_folders (list, optional): Sub folders in root_dir that are used. Defaults to [].

    Raises:
        ValueError: If the function file is not found

    Returns:
        function: FunctionCall object
    """
    try:
        with open(os.path.join(root_dir, file_name), "r") as file:
            # Read the contents of the file
            file_contents = file.read()
    except FileNotFoundError:
        raise ValueError(
            f"The file '{os.path.join(root_dir, file_name)}' was not found."
        )

    # ignore the comments enclosed in %{ ... }%
    file_contents = remove_cmt_paragraph(file_contents)

    # initialize the function
    input_vars = []
    output_vars = []
    if file_name[:-2] in function_attributes.keys():
        input_vars = function_attributes[file_name[:-2]]["input"]
        output_vars = function_attributes[file_name[:-2]]["output"]

    function = FunctionCall(file_name[:-2], input_vars, output_vars)
    # add the non-visited function to the function list
    if not function_called(file_name[:-2], visited_funcs):
        visited_funcs.append(function)

    # connect the function to its parent node if exists
    if parent_func:
        if function in parent_func.child_nodes:
            return
        else:
            parent_func.add_child_node(function)
            function.add_parent_node(parent_func)

    call_analysis_code(
        file_contents,
        function,
        function_attributes,
        root_dir,
        sub_func_folders,
        visited_funcs,
    )

    return function


def save_cnt_map(root_node: FunctionCall, json_map: dict):
    """
    Save the Function call tree to json format

    Args:
        root_node (FunctionCall): FunctionCall object of the root node
        json_map (dict): Visited function list

    Returns:
        json_map(dict): Visited function list
    """
    json_key = root_node.func_name
    json_value = {}

    json_value["child_nodes"] = []
    for child_func in root_node.child_nodes:
        json_value["child_nodes"].append(child_func.func_name)

    json_value["parent_nodes"] = []
    for parent_func in root_node.parent_nodes:
        json_value["parent_nodes"].append(parent_func.func_name)

    json_value["input"] = root_node.input_vars
    json_value["output"] = root_node.output_vars
    json_value["cnt_vars_parents"] = root_node.cnt_vars_parents
    json_value["cnt_vars_children"] = root_node.cnt_vars_children

    json_node = {json_key: json_value}
    json_map = {**json_map, **json_node}

    for child_node in root_node.child_nodes:
        json_map = save_cnt_map(child_node, json_map)

    return json_map


def compute_function_dependency(root, leaf_weights, weights_dict={}, total_feat=45):
    """
    Compute the function dependency based on the leaf weights, where the dependency in
    each node is the superset of its child nodes.
    """
    import numpy as np

    cur_node = root
    func_name = cur_node.func_name.split("/")[-1]
    if len(cur_node.child_nodes) == 0:
        if func_name in leaf_weights.keys():
            weights_dict[func_name] = np.array(leaf_weights[func_name]).astype(int)
        else:
            # Parse the function name to get the leaf node features by default
            leaf_feat = func_name[len("Feat") :].split("_")
            weights_dict[func_name] = np.zeros((total_feat,)).astype(int)
            for feat in leaf_feat:
                try:
                    weights_dict[func_name][int(feat) - 1] = 1
                except:
                    raise ValueError(
                        "Leaf node {} need specific features".format(func_name)
                    )
        return weights_dict

    weights_dict[func_name] = np.zeros((total_feat,))
    for node in root.child_nodes:
        weights_dict = compute_function_dependency(node, leaf_weights, weights_dict)
        weights_dict[func_name] = np.logical_or(
            weights_dict[func_name], weights_dict[node.func_name.split("/")[-1]]
        ).astype(int)
    return weights_dict


if __name__ == "__main__":
    import argparse
    import os
    import json

    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--folder", required=True, help="Path to the analyze code directory"
    )
    parser.add_argument(
        "--subfolder",
        required=False,
        default=[],
        action="append",
        help="Relative path to the sub folders in the code directory",
    )
    parser.add_argument("--rootfile", required=True, help="Root function file")
    parser.add_argument(
        "--jsontag", required=True, help="Path to the function attributes file"
    )
    parser.add_argument(
        "--visualize",
        required=False,
        default=0,
        help="whether to visualize the call graph",
    )
    args = parser.parse_args()
    visualize = int(args.visualize)
    folder = args.folder
    json_tag = args.jsontag
    root_file = args.rootfile
    sub_func_folders = args.subfolder

    # Open the JSON file for reading
    with open(json_tag, "r") as file:
        tag_data = json.load(file)

    if root_file.endswith(".m"):
        print("\nprocessing file: ", folder)
        root_node = call_analysis(
            folder, root_file, tag_data, sub_func_folders=sub_func_folders
        )

        if visualize == 1:
            call_graph_viz(root_node, "test1")
        json_file = save_cnt_map(root_node, {})
        with open("./function_call_pattern.json", "w") as outfile:
            json.dump(json_file, outfile, indent=4)
